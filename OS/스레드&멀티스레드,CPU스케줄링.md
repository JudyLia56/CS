# 스레드 & 멀티스레드, CPU 스케줄링

- 기본 용어 정리
    - 프로세서(Processor)
        - 하드웨어적: 컴퓨터 내에서 프로그램을 수행하는 하드웨어 유닛 (ex. CPU) (보통 이 의미로 많이 사용)
        - 소프트웨어적: 데이터 포맷을 변환하는 역할을 수행하는 데이터 처리 시스템 (ex. 워드프로세서, 컴파일러 등)
    - 프로세스(Process): 컴퓨터에서 실행되고 있는 프로그램 및 작업 목록, 스케줄링의 대상
    - 프로그램(Program): 저장공간에 저장된 코드와 리소스 등이 집합되어 있는 파일
    - 스레드(Thread): 프로세스 작업의 단위, 프로세스에서 한 단계 작은 개념.
    

## 스레드 & 프로세스

- 프로세스
    - 실행되면서 시스템 자원(CPU, 메모리 영역(Code, Data, Stack Heap))를 할당 받음.
    - 1개 이상의 스레드를 가지고 있음.
    - 프로세스는 다른 프로세스에 가지고 있는 변수나 데이터에는 직접적으로 접근할 수 없음 ⇒ 여러개의 프로세스를 동시에 많이 만들기 어려움. ⇒ 더 작은 단위가 필요(스레드)
    - 하나의 프로세스에서 오류가 발생할 경우 다른 프로세스는 영향이 없음.
- 스레드
    - 스레드끼리 프로세스 내의 메모리를 사용하고 작동할 수 있음.
    - 개별적인 stack메모리와 PC register를 가짐. (나머지 부분은 공유)
        - stack은 독립적인 실행 흐름을 추가하기 위한 최소의 조건이기 때문에 개별적으로 가짐.
        - PC register는 스레드가 어디까지 수행하였는지 나타냄 (스레드는 CPU를 할당받았다 다시 선점이 되기 때문에 어디까지 수행했는지 확인이 필요함.)
    - 하나의 스레드에서 오류가 발생할 경우 같은 프로세스 내의 다른 스레드들도 다 종료
- 참고 사진
    
    ![Untitled](%E1%84%89%E1%85%B3%E1%84%85%E1%85%A6%E1%84%83%E1%85%B3%20&%20%E1%84%86%E1%85%A5%E1%86%AF%E1%84%90%E1%85%B5%E1%84%89%E1%85%B3%E1%84%85%E1%85%A6%E1%84%83%E1%85%B3,%20CPU%20%E1%84%89%E1%85%B3%E1%84%8F%E1%85%A6%E1%84%8C%E1%85%AE%E1%86%AF%E1%84%85%E1%85%B5%E1%86%BC%20a285c81f454f4468947140b43252b176/Untitled.png)
    

## 멀티 스레드 & 멀티 프로세스

- 멀티 태스킹
    - 하나의 운영체제 안에서 여러 프로세스가 실행되는 것
    - 동시에 실행되는 것처럼 보이지만 실제로는 CPU 스케줄링에 의해 번갈아 실행되는 것
- 멀티 스레드
    - 하나의 프로세스가 여러 스레드로 여러 작업을 수행하는 것
    - 장점
        - 프로세스 내의 메모리 영역을 공유하기 떄문에 데이터를 주고 받기 쉬움.
        - 문맥교환(현재 작업상태나 다음 작업에 필요한 데이터들을 저장하고 읽는 것)이 빠름
        - 스레드 간 통신 비용은 적기 때문에 부담이 적음
    - 단점
        - 하나의 스레드에 문제가 생기면 해당 프로세스에 영향을 미침
        - 메모리의 여러 영역을 공유하기 때문에 동기화 문제.
- 멀티 프로세스
    - 두 개 이상의 프로세서가 하나의 작업을 동시에 처리하는 것
    - 하나의 프로그램을 여러 개의 프로세스로 구성
    - IPC(Inter - Process Communication): 프로세스끼리 데이터를 주고 받고, 공유 데이터를 관리하는 법
    - 장점: 하나의 프로세스에 문제가 생겨도 다른 프로세스에 영향을 주지 않음
    - 단점: 독립된 메모리 영역이므로 작업량이 많으면 성능저하 발생
- 간단 정리
    
    ![Untitled](%E1%84%89%E1%85%B3%E1%84%85%E1%85%A6%E1%84%83%E1%85%B3%20&%20%E1%84%86%E1%85%A5%E1%86%AF%E1%84%90%E1%85%B5%E1%84%89%E1%85%B3%E1%84%85%E1%85%A6%E1%84%83%E1%85%B3,%20CPU%20%E1%84%89%E1%85%B3%E1%84%8F%E1%85%A6%E1%84%8C%E1%85%AE%E1%86%AF%E1%84%85%E1%85%B5%E1%86%BC%20a285c81f454f4468947140b43252b176/Untitled%201.png)
    
- 멀티 스레드 VS 멀티 프로세스
    
    ![Untitled](%E1%84%89%E1%85%B3%E1%84%85%E1%85%A6%E1%84%83%E1%85%B3%20&%20%E1%84%86%E1%85%A5%E1%86%AF%E1%84%90%E1%85%B5%E1%84%89%E1%85%B3%E1%84%85%E1%85%A6%E1%84%83%E1%85%B3,%20CPU%20%E1%84%89%E1%85%B3%E1%84%8F%E1%85%A6%E1%84%8C%E1%85%AE%E1%86%AF%E1%84%85%E1%85%B5%E1%86%BC%20a285c81f454f4468947140b43252b176/Untitled%202.png)
    

## CPU 스케줄링

- 스케줄링
    - 프로세스의 작업 수행을 위해 CPU를 할당하는 것
    - 기법에 따라 CPU 자원을 얼마나 효율적으로 사용하게 되는지 결정됨.
- 비선점형
    - 하나의 프로세스가 CPU를 점유하고 있을 경우 그 작업이 완료될 때까지 다른 프로세스가 CPU를 사용할 수 없음
    - 프로세스 강제 종료 X, 프로세스 스스로 CPU 소유권을 포기
    - Context Switching으로 인한 부하가 적음
    - 급한 프로세스가 빠르게 처리되지 못하는 문제 발생
    - FCFS(First Come First Service)
        - 들어온 순서대로 CPU에 할당하는 방식
        - 작업완료 시간을 예측하기 쉬움
        - 수행시간이 긴 프로세스가 있을 경우 다른 프로세스들이 오래 기다리게 되는 convey effect발생
    - SJF(Shortest Job First)
        - 실행 시간이 가장 짧은 순서대로 CPU에 할당
        - 대기 시간이 가장 짧음
        - 실행 시간이 긴 프로세스가 수행되지 못하고 계속 뒤로 밀리는 현상 Starvation발생
    - 우선순위
        - 대기 중인 프로세스들에게 우선 순위를 부여하여 CPU에 할당
        - 제한 시간, 기억장소 요청량, 사용 파일 수, 중요성 등등을 요소로 우선순위 부여
        - Aging 기법: 우선 순위가 낮은 프로세스더라도 대기시간이 길어지면 순위를 높임 → Staravation 해결
        - 더 높은 우선순위 프로세스가 들어오면 Head에 넣음
        - (선점형) 더 높은 우선 순위 프로세스가 도착하면 실행되면 프로세스를 멈추고 CPU를 선점.
- 선점형
    - 한 프로세스가 CPU에 할당되어 실행 중일 때 다른 프로세스가 그 프로세스를 중지시키고 CPU에 할당 받는 기법
    - 급한 프로세스가 있을 경우 용이
    - Context Switching이 자주 발생
    - 라운드로빈(Round Robin)
        - FCFS과 Time Quantum을 추가한 방식
        - Time Quantum : CPU를 연속적으로 사용할 수 있는 시간에 제한을 두는 것
        - 먼저 들어오는 순서대로 CPU에 할당되지만 특정 시간이 지나면 순서를 뒤로 보내는 것
        - Time Quantum이 크면 FCFS와 다를게 없어지고 작으면 Context Switching이 너무 많이 발생해 오버헤드가 커짐
        - 작업시간은 늘지만 평균 응답시간은 짧아짐.
    - SRF(Shortest Remaining Time)
        - SJF를 선점형으로 한 것
        - 현재 CPU를 점유중인 프로세스의 남은 처리시간보다 CPU 처리 시간이 짧은 프로세스가 들어오는 경우 새로 들어온 프로세스가 CPU를 점유
        - 평균 대기시간이 짧음
        - 프로세스 종료시간의 예측이 어렵고 기아 현상 발생
    - 다단계 큐
        - 우선 순위에 따른 ReadyQueue를 여러개 사용
        - 우선순위에 따라 큐에 삽입됨
        - 큐마다 RR, FCFS등 다른 스케줄링 방식을 적용
        - 상단의 큐의 프로세스들의 작업이 끝나야 다음 우선순위의 큐의 프로세스들의 작업 시작
        - 우선순위에 따른 다양한 스케줄링이 가능
        - 큐 간의 프로세스 이동이 불가해 유연성 감소.
